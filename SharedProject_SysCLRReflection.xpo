Exportfile for AOT version 1.0 or later
Formatversion: 1

***Element: CLS

; Microsoft Dynamics AX Class: SysCLRReflection выгружен
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #SysCLRReflection
    PROPERTIES
      Name                #SysCLRReflection
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #/// <summary>
        #/// https://github.com/d-tolstov/Ax2009-SysCLRReflection
        #/// Класс аггрегирует в себе функции для работы с рефлексией
        #/// </summary>
        #/// <remarks>
        #///
        #/// </remarks>
        #class SysCLRReflection
        #{
        #}
      ENDSOURCE
      SOURCE #getArray
        #/// <summary>
        #/// Преобразование списка параметров в массив System.Object[]
        #/// Если указанного кол-ва параметров не хватает, то используйте функцию getArrayFromContainer
        #/// </summary>
        #/// <param name="_parameter1">
        #/// Первый параметр
        #/// </param>
        #/// <param name="_parameter2">
        #/// Второй параметр
        #/// </param>
        #/// <param name="_parameter3">
        #/// Третий параметр
        #/// </param>
        #/// <param name="_parameter4">
        #/// Четвертый параметр
        #/// </param>
        #/// <returns>
        #/// Массив параметров System.Object[]
        #/// </returns>
        #/// <remarks>
        #///
        #/// </remarks>
        #static System.Object[] getArray(
        #    anytype     _parameter1 = null
        #  , anytype     _parameter2 = null
        #  , anytype     _parameter3 = null
        #  , anytype     _parameter4 = null
        #)
        #{
        #    System.Object[]     ret;
        #    int                 parametersCount;
        #;
        #    if ( prmisdefault(_parameter1))
        #    {
        #        parametersCount = 0;
        #    }
        #    else
        #    if ( prmisdefault(_parameter2))
        #    {
        #        parametersCount = 1;
        #    }
        #    else
        #    if ( prmisdefault(_parameter3))
        #    {
        #        parametersCount = 2;
        #    }
        #    else
        #    if ( prmisdefault(_parameter4))
        #    {
        #        parametersCount = 3;
        #    }
        #    else
        #    {
        #        parametersCount = 4;
        #    }
        #
        #    ret = new System.Object[parametersCount]();
        #
        #    if ( !prmisdefault(_parameter1))
        #    {
        #        ret.SetValue( _parameter1, 0);
        #    }
        #    if ( !prmisdefault(_parameter2))
        #    {
        #        ret.SetValue( _parameter2, 1);
        #    }
        #    if ( !prmisdefault(_parameter3))
        #    {
        #        ret.SetValue( _parameter3, 2);
        #    }
        #    if ( !prmisdefault(_parameter4))
        #    {
        #        ret.SetValue( _parameter4, 3);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #getArrayFromContainer
        #/// <summary>
        #/// Преобразование списка параметров из контейнера в массив System.Object[]
        #/// </summary>
        #/// <param name="_parametersContainer">
        #/// Контейнер с параметрами
        #/// </param>
        #/// <returns>
        #/// Массив параметров System.Object[]
        #/// </returns>
        #/// <remarks>
        #///
        #/// </remarks>
        #static System.Object[] getArrayFromContainer(
        #    container   _parametersContainer = connull()
        #)
        #{
        #    System.Object[]     ret;
        #    int                 parametersCount;
        #    int                 i;
        #;
        #    parametersCount = conlen( _parametersContainer);
        #
        #    ret = new System.Object[parametersCount]();
        #
        #    for (i=1; i<=parametersCount; i++)
        #    {
        #        ret.SetValue( conpeek( _parametersContainer, i), i-1);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #getPropertyValue
        #/// <summary>
        #/// Получение свойства CLR-объекта
        #/// </summary>
        #/// <param name="_class">
        #/// Объект
        #/// </param>
        #/// <param name="_propertyName">
        #/// Название свойства
        #/// </param>
        #/// <returns>
        #/// Значение свойства
        #/// </returns>
        #/// <remarks>
        #///
        #/// </remarks>
        #static System.Object getPropertyValue(
        #    System.Object      _class
        #  , str                _propertyName
        #)
        #{
        #    return SysCLRReflection::getPropertyValuePrivate(
        #        _class
        #      , _propertyName
        #    );
        #}
      ENDSOURCE
      SOURCE #getPropertyValueIndex
        #/// <summary>
        #/// Получение свойства CLR-объекта с индексом
        #/// </summary>
        #/// <param name="_class">
        #/// Объект
        #/// </param>
        #/// <param name="_propertyName">
        #/// Название свойства
        #/// </param>
        #/// <param name="_index">
        #/// Индекс свойства
        #/// </param>
        #/// <returns>
        #/// Значение свойства
        #/// </returns>
        #/// <remarks>
        #///
        #/// </remarks>
        #static System.Object getPropertyValueIndex(
        #    System.Object       _class
        #  , str                 _propertyName
        #  , anytype             _index
        #)
        #{
        #    return SysCLRReflection::getPropertyValuePrivate(
        #        _class
        #      , _propertyName
        #      , SysCLRReflection::getArray( _index)
        #    );
        #}
      ENDSOURCE
      SOURCE #getPropertyValuePrivate
        #/// <summary>
        #/// Общая функция для получения свойства CLR-объекта. Без индексов и с индексами.
        #/// </summary>
        #/// <param name="_class">
        #/// Объект
        #/// </param>
        #/// <param name="_propertyName">
        #/// Название свойства
        #/// </param>
        #/// <param name="_parametersArray">
        #/// Массив индексов свойства
        #/// </param>
        #/// <returns>
        #/// Значение свойства
        #/// </returns>
        #/// <remarks>
        #///
        #/// </remarks>
        #/// <exception cref="Exception::Error">
        #///
        #/// </exception>
        #/// <exception cref="Exception::Error">
        #///
        #/// </exception>
        #private static System.Object getPropertyValuePrivate(
        #    System.Object      _class
        #  , str                _propertyName
        #  , System.Object[]    _parametersArray = null
        #)
        #{
        #    System.Type                         classType;
        #    System.Reflection.PropertyInfo      propertyInfo;
        #
        #    System.Object                       ret;
        #
        #    try
        #    {
        #        if ( !_parametersArray
        #          || CLRInterop::isNull( _parametersArray) )
        #        {
        #            _parametersArray    = new System.Object[0]();
        #        }
        #
        #        classType       = _class.GetType();
        #
        #        propertyInfo    = classType.GetProperty(_propertyName);
        #        if ( !CLRInterop::isNull(propertyInfo))
        #        {
        #            ret = propertyInfo.GetValue( _class, _parametersArray);
        #        }
        #        else
        #            throw Error(strfmt("Свойство %1 в классе %2 не найдено!", _propertyName, CLRInterop::getAnyTypeForObject(classType.ToString())));
        #    }
        #    catch (Exception::CLRError)
        #    {
        #        throw error(AifUtil::getClrErrorMessage());
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #getTypeArray
        #/// <summary>
        #/// Получение массива типов System.Type[] для generic-функций
        #/// </summary>
        #/// <param name="_type1">
        #/// Первый тип
        #/// </param>
        #/// <param name="_type2">
        #/// Второй тип
        #/// </param>
        #/// <param name="_type3">
        #/// Третий тип
        #/// </param>
        #/// <param name="_type4">
        #/// Четвертый тип
        #/// </param>
        #/// <param name="_type5">
        #/// Пятый тип
        #/// </param>
        #/// <param name="_type6">
        #/// Шестой тип
        #/// </param>
        #/// <returns>
        #/// Массив типов
        #/// </returns>
        #/// <remarks>
        #///
        #/// </remarks>
        #static System.Type[] getTypeArray(
        #    System.Type     _type1 = null
        #  , System.Type     _type2 = null
        #  , System.Type     _type3 = null
        #  , System.Type     _type4 = null
        #  , System.Type     _type5 = null
        #  , System.Type     _type6 = null
        #)
        #{
        #    System.Type[]   ret;
        #    int             typeCount;
        #;
        #    if ( prmisdefault(_type1))
        #    {
        #        typeCount = 0;
        #    }
        #    else
        #    if ( prmisdefault(_type2))
        #    {
        #        typeCount = 1;
        #    }
        #    else
        #    if ( prmisdefault(_type3))
        #    {
        #        typeCount = 2;
        #    }
        #    else
        #    if ( prmisdefault(_type4))
        #    {
        #        typeCount = 3;
        #    }
        #    else
        #    if ( prmisdefault(_type5))
        #    {
        #        typeCount = 4;
        #    }
        #    else
        #    if ( prmisdefault(_type6))
        #    {
        #        typeCount = 5;
        #    }
        #    else
        #    {
        #        typeCount = 6;
        #    }
        #
        #    ret = new System.Type[typeCount]();
        #
        #    if ( !prmisdefault(_type1))
        #    {
        #        ret.SetValue( _type1, 0);
        #    }
        #    if ( !prmisdefault(_type2))
        #    {
        #        ret.SetValue( _type2, 1);
        #    }
        #    if ( !prmisdefault(_type3))
        #    {
        #        ret.SetValue( _type3, 2);
        #    }
        #    if ( !prmisdefault(_type4))
        #    {
        #        ret.SetValue( _type4, 3);
        #    }
        #    if ( !prmisdefault(_type5))
        #    {
        #        ret.SetValue( _type5, 4);
        #    }
        #    if ( !prmisdefault(_type6))
        #    {
        #        ret.SetValue( _type6, 5);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #getTypeArrayFromParametersArray
        #/// <summary>
        #/// Получение массива типов System.Type[] из массива параметров
        #/// </summary>
        #/// <param name="_parameters">
        #/// Массив параметров
        #/// </param>
        #/// <returns>
        #/// Массив типов
        #/// </returns>
        #/// <remarks>
        #///
        #/// </remarks>
        #static System.Type[] getTypeArrayFromParametersArray(
        #    System.Object[] _parameters
        #)
        #{
        #    System.Type[]   ret;
        #    System.Object   parameter;
        #    int             typeCount;
        #    int             i;
        #;
        #    if ( _parameters
        #      && !CLRInterop::isNull(_parameters))
        #    {
        #        typeCount   = _parameters.get_Length();
        #    }
        #
        #    ret = new System.Type[typeCount]();
        #
        #    for (i=0; i<typeCount; i++)
        #    {
        #        parameter   = _parameters.GetValue(i);
        #        ret.SetValue( parameter.GetType(), i);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #invokeMethod
        #/// <summary>
        #/// Вызов обычной функции CLR-объекта
        #/// </summary>
        #/// <param name="_object">
        #/// Объект
        #/// </param>
        #/// <param name="_methodName">
        #/// Название функции
        #/// </param>
        #/// <param name="_parameters">
        #/// Массив параметров (можно сформировать с помощью функций getArray и getArrayFromContainer)
        #/// </param>
        #/// <param name="_overloaded">
        #/// Устанавливается в true для функций, имеющих несколько перегрузок
        #/// </param>
        #/// <returns>
        #/// Возвращаемый функцией результат
        #/// </returns>
        #/// <remarks>
        #///
        #/// </remarks>
        #static System.Object invokeMethod(
        #    System.Object       _object
        #  , str                 _methodName
        #  , System.Object[]     _parameters = null
        #  , boolean             _overloaded = false
        #)
        #{
        #    return SysCLRReflection::invokeMethodGeneric(
        #        _object
        #      , _methodName
        #      , null
        #      , _parameters
        #      , _overloaded
        #    );
        #}
      ENDSOURCE
      SOURCE #invokeMethodGeneric
        #/// <summary>
        #/// Общая функция для вызова функций CLR-объекта. Обычных или generic-функций.
        #/// </summary>
        #/// <param name="_object">
        #/// Объект
        #/// </param>
        #/// <param name="_methodName">
        #/// Название функции
        #/// </param>
        #/// <param name="_methodTypeArray">
        #/// Массив типов для generic-функций (можно сформировать с помощью функции getTypeArray)
        #/// </param>
        #/// <param name="_parametersArray">
        #/// Массив параметров (можно сформировать с помощью функций getArray и getArrayFromContainer)
        #/// </param>
        #/// <param name="_overloaded">
        #/// Устанавливается в true для функций, имеющих несколько перегрузок
        #/// </param>
        #/// <returns>
        #/// Возвращаемый функцией результат
        #/// </returns>
        #/// <remarks>
        #///
        #/// </remarks>
        #/// <exception cref="Exception::Error">
        #///
        #/// </exception>
        #/// <exception cref="Exception::Error">
        #///
        #/// </exception>
        #private static System.Object invokeMethodGeneric(
        #    System.Object       _object
        #  , str                 _methodName
        #  , System.Type[]       _methodTypeArray    = null
        #  , System.Object[]     _parametersArray    = null
        #  , boolean             _overloaded         = false
        #)
        #{
        #    System.Type                     classType;
        #    System.Type                     parameterType;
        #    int                             parametersCount;
        #    int                             i;
        #    //BP deviation documented
        #    System.Type[]                   parameterTypes;
        #    //BP deviation documented
        #    System.Object                   parameter;
        #
        #    System.Reflection.MethodInfo    methodInfo;
        #    System.Object                   ret;
        #
        #    System.Exception                e;
        #
        #    System.Reflection.MethodInfo[]      methods;
        #    int                                 methodsQty, genericMethodParametersQty, j;
        #    str                                 genericMethodName;
        #    System.Reflection.ParameterInfo[]   genericMethodParameters;
        #    System.Reflection.ParameterInfo     genericMethodParameterInfo;
        #    System.Type                         genericMethodParameterType;
        #    System.Reflection.MethodInfo        genericMethodInfo;
        #    boolean                             parametersEqual;
        #
        #    try
        #    {
        #        classType      = _object.GetType();
        #
        #        if ( !_parametersArray
        #          || CLRInterop::isNull( _parametersArray) )
        #        {
        #            _parametersArray    = new System.Object[0]();
        #        }
        #
        #        if (_overloaded)
        #        {
        #            if ( !_methodTypeArray
        #              || CLRInterop::isNull( _methodTypeArray) )
        #            {
        #                _methodTypeArray    = new System.Type[0]();
        #            }
        #
        #            parametersCount = _parametersArray.get_Length();
        #            parameterTypes  = new System.Type[parametersCount]();
        #
        #            for (i = 0; i < parametersCount; i++)
        #            {
        #                parameter = _parametersArray.GetValue(i);
        #                parameterType = parameter.GetType();
        #                parameterTypes.SetValue(parameterType, i);
        #            }
        #
        #            methodInfo = classType.GetMethod(_methodName, parameterTypes); //Gets overload with parameters specified
        #
        #            if (! methodInfo)
        #            {
        #                methods     = classType.GetMethods();
        #                methodsQty  = methods.get_Length();
        #
        #                for (i = 1; i <= methodsQty; i++)
        #                {
        #                    methodInfo          = methods.GetValue(i-1);
        #                    genericMethodName   = methodInfo.get_Name();
        #
        #                    if (genericMethodName == _methodName)
        #                    {
        #                        genericMethodInfo           = methodInfo.MakeGenericMethod(_methodTypeArray);
        #                        genericMethodParameters     = genericMethodInfo.GetParameters();
        #                        genericMethodParametersQty  = genericMethodParameters.get_Length();
        #
        #                        if (genericMethodParametersQty == parametersCount)
        #                        {
        #                            parametersEqual = true;
        #
        #                            for (j = 1; j <= genericMethodParametersQty; j++)
        #                            {
        #                                genericMethodParameterInfo  = genericMethodParameters.GetValue(j-1);
        #                                genericMethodParameterType  = genericMethodParameterInfo.get_ParameterType();
        #                                parameter                   = _parametersArray.GetValue( j - 1);
        #                                parameterType               = parameter.GetType();
        #
        #                                if (! genericMethodParameterType.Equals(parameterType))
        #                                {
        #                                    parametersEqual = false;
        #                                }
        #                            }
        #
        #                            if (parametersEqual)
        #                            {
        #                                break;
        #                            }
        #                            else
        #                            {
        #                                methodInfo = null;
        #                            }
        #                        }
        #                    }
        #                    else
        #                    {
        #                        methodInfo = null;
        #                    }
        #                }
        #            }
        #
        #            if ( CLRInterop::isNull(methodInfo))
        #                throw Error( strfmt("Метод %1%2 в классе %3 не найден!"
        #                           , _methodName
        #                           , ( !CLRInterop::isNull(_methodTypeArray)
        #                            && CLRInterop::getAnyTypeForObject(_methodTypeArray.get_Length()) != 0)
        #                           ? strfmt( "<%1>", SysCLRReflection::typeArray2Str( _methodTypeArray))
        #                           : ""
        #                           , CLRInterop::getAnyTypeForObject(classType.ToString()))
        #                           );
        #        }
        #        else
        #        {
        #            methodInfo = classType.GetMethod(_methodName);
        #
        #            if ( CLRInterop::isNull(methodInfo))
        #                throw Error( strfmt("Метод %1 в классе %2 не найден!"
        #                           , _methodName
        #                           , CLRInterop::getAnyTypeForObject(classType.ToString()))
        #                           );
        #        }
        #
        #        if ( _methodTypeArray
        #          && methodInfo.get_IsGenericMethod())
        #        {
        #            methodInfo = methodInfo.MakeGenericMethod(_methodTypeArray);         //Gets generic method of specified type(s)
        #        }
        #
        #        ret = methodInfo.Invoke( _object, _parametersArray);
        #    }
        #    catch (Exception::CLRError)
        #    {
        #        //BP deviation documented
        #        e = CLRInterop::getLastException();
        #        throw error(e.ToString());
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #invokeMethodGenericType
        #/// <summary>
        #/// Вызов generic-функции CLR-объекта. С указанием одного типа generic.
        #/// </summary>
        #/// <param name="_object">
        #/// Объект
        #/// </param>
        #/// <param name="_methodName">
        #/// Название функции
        #/// </param>
        #/// <param name="_methodType">
        #/// Тип generic
        #/// </param>
        #/// <param name="_parameters">
        #/// Массив параметров (можно сформировать с помощью функций getArray и getArrayFromContainer)
        #/// </param>
        #/// <param name="_overloaded">
        #/// Устанавливается в true для функций, имеющих несколько перегрузок
        #/// </param>
        #/// <returns>
        #/// Возвращаемый функцией результат
        #/// </returns>
        #/// <remarks>
        #///
        #/// </remarks>
        #static System.Object invokeMethodGenericType(
        #    System.Object       _object
        #  , str                 _methodName
        #  , System.Type         _methodType
        #  , System.Object[]     _parameters = null
        #  , boolean             _overloaded = false
        #)
        #{
        #    return SysCLRReflection::invokeMethodGeneric(
        #        _object
        #      , _methodName
        #      , SysCLRReflection::getTypeArray( _methodType)
        #      , _parameters
        #      , _overloaded
        #    );
        #}
      ENDSOURCE
      SOURCE #invokeMethodGenericType2
        #/// <summary>
        #/// Вызов generic-функции CLR-объекта. С указанием двух типов generic.
        #/// </summary>
        #/// <param name="_object">
        #/// Объект
        #/// </param>
        #/// <param name="_methodName">
        #/// Название функции
        #/// </param>
        #/// <param name="_methodType1">
        #/// Первый тип generic
        #/// </param>
        #/// <param name="_methodType2">
        #/// Второй тип generic
        #/// </param>
        #/// <param name="_parameters">
        #/// Массив параметров (можно сформировать с помощью функций getArray и getArrayFromContainer)
        #/// </param>
        #/// <param name="_overloaded">
        #/// Устанавливается в true для функций, имеющих несколько перегрузок
        #/// </param>
        #/// <returns>
        #/// Возвращаемый функцией результат
        #/// </returns>
        #/// <remarks>
        #///
        #/// </remarks>
        #static System.Object invokeMethodGenericType2(
        #    System.Object       _object
        #  , str                 _methodName
        #  , System.Type         _methodType1
        #  , System.Type         _methodType2
        #  , System.Object[]     _parameters = null
        #  , boolean             _overloaded = false
        #)
        #{
        #    return SysCLRReflection::invokeMethodGeneric(
        #        _object
        #      , _methodName
        #      , SysCLRReflection::getTypeArray( _methodType1, _methodType2)
        #      , _parameters
        #      , _overloaded
        #    );
        #}
      ENDSOURCE
      SOURCE #invokeMethodGenericTypeName
        #/// <summary>
        #/// Вызов generic-функции CLR-объекта. С указанием одного типа generic по его названию.
        #/// </summary>
        #/// <param name="_object">
        #/// Объект
        #/// </param>
        #/// <param name="_methodName">
        #/// Название функции
        #/// </param>
        #/// <param name="_methodTypeName">
        #/// Название типа generic
        #/// </param>
        #/// <param name="_parameters">
        #/// Массив параметров (можно сформировать с помощью функций getArray и getArrayFromContainer)
        #/// </param>
        #/// <param name="_overloaded">
        #/// Устанавливается в true для функций, имеющих несколько перегрузок
        #/// </param>
        #/// <returns>
        #/// Возвращаемый функцией результат
        #/// </returns>
        #/// <remarks>
        #///
        #/// </remarks>
        #static System.Object invokeMethodGenericTypeName(
        #    System.Object       _object
        #  , str                 _methodName
        #  , str                 _methodTypeName
        #  , System.Object[]     _parameters = null
        #  , boolean             _overloaded = false
        #)
        #{
        #    return SysCLRReflection::invokeMethodGenericType(
        #        _object
        #      , _methodName
        #      , SysCLRType::newFromTypeName( _methodTypeName).parmClrType()
        #      , _parameters
        #      , _overloaded
        #    );
        #}
      ENDSOURCE
      SOURCE #invokeMethodGenericTypeName2
        #/// <summary>
        #/// Вызов generic-функции CLR-объекта. С указанием двух типов generic по их названию.
        #/// </summary>
        #/// <param name="_object">
        #/// Объект
        #/// </param>
        #/// <param name="_methodName">
        #/// Название функции
        #/// </param>
        #/// <param name="_methodTypeName1">
        #/// Название первого типа generic
        #/// </param>
        #/// <param name="_methodTypeName2">
        #/// Название второго типа generic
        #/// </param>
        #/// <param name="_parameters">
        #/// Массив параметров (можно сформировать с помощью функций getArray и getArrayFromContainer)
        #/// </param>
        #/// <param name="_overloaded">
        #/// Устанавливается в true для функций, имеющих несколько перегрузок
        #/// </param>
        #/// <returns>
        #/// Возвращаемый функцией результат
        #/// </returns>
        #/// <remarks>
        #///
        #/// </remarks>
        #static System.Object invokeMethodGenericTypeName2(
        #    System.Object       _object
        #  , str                 _methodName
        #  , str                 _methodTypeName1
        #  , str                 _methodTypeName2
        #  , System.Object[]     _parameters = null
        #  , boolean             _overloaded = false
        #)
        #{
        #    return SysCLRReflection::invokeMethodGenericType2(
        #        _object
        #      , _methodName
        #      , SysCLRType::newFromTypeName( _methodTypeName1).parmClrType()
        #      , SysCLRType::newFromTypeName( _methodTypeName2).parmClrType()
        #      , _parameters
        #      , _overloaded
        #    );
        #}
      ENDSOURCE
      SOURCE #invokeStatic
        #/// <summary>
        #/// Вызов статической функции класса. С указанием типа класса.
        #/// </summary>
        #/// <param name="_classType">
        #/// Тип класса
        #/// </param>
        #/// <param name="_methodName">
        #/// Название функции
        #/// </param>
        #/// <param name="_parametersArray">
        #/// Массив параметров (можно сформировать с помощью функций getArray и getArrayFromContainer)
        #/// </param>
        #/// <param name="_overloaded">
        #/// Устанавливается в true для функций, имеющих несколько перегрузок
        #/// </param>
        #/// <returns>
        #/// Возвращаемый функцией результат
        #/// </returns>
        #/// <remarks>
        #///
        #/// </remarks>
        #static System.Object invokeStatic(
        #    System.Type        _classType
        #  , str                _methodName
        #  , System.Object[]    _parametersArray = null
        #  , boolean            _overloaded      = false
        #)
        #{
        #    return SysCLRReflection::invokeStaticGeneric(
        #        _classType
        #      , _methodName
        #      , null
        #      , _parametersArray
        #      , _overloaded
        #    );
        #}
      ENDSOURCE
      SOURCE #invokeStaticGeneric
        #/// <summary>
        #/// Вызов статической generic-функции класса. С указанием типа класса.
        #/// </summary>
        #/// <param name="_classType">
        #/// Тип класса
        #/// </param>
        #/// <param name="_methodName">
        #/// Название функции
        #/// </param>
        #/// <param name="_methodTypeArray">
        #/// Массив типов generic (можно сформировать с помощью функции getTypeArray)
        #/// </param>
        #/// <param name="_parametersArray">
        #/// Массив параметров (можно сформировать с помощью функций getArray и getArrayFromContainer)
        #/// </param>
        #/// <param name="_overloaded">
        #/// Устанавливается в true для функций, имеющих несколько перегрузок
        #/// </param>
        #/// <returns>
        #/// Возвращаемый функцией результат
        #/// </returns>
        #/// <remarks>
        #///
        #/// </remarks>
        #static System.Object invokeStaticGeneric(
        #    System.Type        _classType
        #  , str                _methodName
        #  , System.Type[]      _methodTypeArray
        #  , System.Object[]    _parametersArray
        #  , boolean            _overloaded = false
        #)
        #{
        #    System.Type                         parameterType;
        #    int                                 parametersCount;
        #    int                                 i;
        #    //BP deviation documented
        #    System.Type[]                       parameterTypes;
        #    System.Object                       parameter;
        #
        #    System.Reflection.MethodInfo        methodInfo;
        #    System.Object                       ret;
        #
        #    System.Exception                    e;
        #
        #    System.Reflection.MethodInfo[]      methods;
        #    int                                 methodsQty, genericMethodParametersQty, j;
        #    str                                 genericMethodName;
        #    System.Reflection.ParameterInfo[]   genericMethodParameters;
        #    System.Type[]                       genericMethodTypeParameters;
        #    System.Reflection.ParameterInfo     genericMethodParameterInfo;
        #    System.Type                         genericMethodParameterType;
        #    System.Reflection.MethodInfo        genericMethodInfo;
        #    boolean                             parametersEqual;
        #
        #    int                                 methodTypeParametersCount;
        #
        #    try
        #    {
        #        if ( !_parametersArray
        #          || CLRInterop::isNull( _parametersArray) )
        #        {
        #            _parametersArray    = new System.Object[0]();
        #        }
        #
        #        parametersCount = _parametersArray.get_Length();
        #        parameterTypes  = new System.Type[parametersCount]();
        #
        #        for (i = 0; i < parametersCount; i++)
        #        {
        #            parameter = _parametersArray.GetValue(i);
        #            parameterType = parameter.GetType();
        #            parameterTypes.SetValue(parameterType, i);
        #        }
        #
        #        if ( !_methodTypeArray
        #          || CLRInterop::isNull( _methodTypeArray) )
        #        {
        #            _methodTypeArray    = new System.Type[0]();
        #        }
        #        methodTypeParametersCount = ClrInterop::getAnyTypeForObject(_methodTypeArray.get_Length());
        #
        #        if (_overloaded)
        #        {
        #            methodInfo = _classType.GetMethod(_methodName, parameterTypes); //Gets overload with parameters specified
        #
        #            if (! methodInfo)
        #            {
        #                methods     = _classType.GetMethods();
        #                methodsQty  = methods.get_Length();
        #
        #                for (i = 1; i <= methodsQty; i++)
        #                {
        #                    methodInfo          = methods.GetValue(i-1);
        #                    genericMethodName   = methodInfo.get_Name();
        #
        #                    if (genericMethodName == _methodName)
        #                    {
        #                        if ( methodInfo.get_IsGenericMethodDefinition())
        #                        {
        #                            genericMethodTypeParameters = methodInfo.GetGenericArguments();
        #                            if ( ClrInterop::getAnyTypeForObject(genericMethodTypeParameters.get_Length()) != methodTypeParametersCount )
        #                            {
        #                                methodInfo = null;
        #                                continue;
        #                            }
        #                            genericMethodInfo           = methodInfo.MakeGenericMethod(_methodTypeArray);
        #                        }
        #                        else
        #                        {
        #                            genericMethodInfo           = methodInfo;
        #                        }
        #                        genericMethodParameters     = genericMethodInfo.GetParameters();
        #                        genericMethodParametersQty  = genericMethodParameters.get_Length();
        #
        #                        if (genericMethodParametersQty == parametersCount)
        #                        {
        #                            parametersEqual = true;
        #
        #                            for (j = 1; j <= genericMethodParametersQty; j++)
        #                            {
        #                                genericMethodParameterInfo  = genericMethodParameters.GetValue(j-1);
        #                                genericMethodParameterType  = genericMethodParameterInfo.get_ParameterType();
        #                                parameter                   = _parametersArray.GetValue(j-1);
        #                                parameterType               = parameter.GetType();
        #
        #                                if ( !genericMethodParameterType.Equals(parameterType)
        #                                  && !CLRInterop::getAnyTypeForObject(genericMethodParameterType.IsAssignableFrom(parameterType)))
        #                                {
        #                                    parametersEqual = false;
        #                                }
        #                            }
        #
        #                            if (parametersEqual)
        #                            {
        #                                break;
        #                            }
        #                            else
        #                            {
        #                                methodInfo = null;
        #                            }
        #                        }
        #                    }
        #                    else
        #                    {
        #                        methodInfo = null;
        #                    }
        #                }
        #            }
        #        }
        #        else
        #        {
        #            methodInfo = _classType.GetMethod(_methodName);
        #        }
        #
        #        if ( CLRInterop::isNull(methodInfo))
        #            throw Error( strfmt("Метод %1%2 в классе %3 не найден!"
        #                       , _methodName
        #                       , ( !CLRInterop::isNull(_methodTypeArray)
        #                        && CLRInterop::getAnyTypeForObject(_methodTypeArray.get_Length()) != 0)
        #                       ? strfmt( "<%1>", SysCLRReflection::typeArray2Str( _methodTypeArray))
        #                       : ""
        #                       , CLRInterop::getAnyTypeForObject(_classType.ToString()))
        #                       );
        #
        #        if ( methodInfo.get_IsGenericMethod())
        #            methodInfo = methodInfo.MakeGenericMethod(_methodTypeArray);         //Gets generic method of specified type(s)
        #
        #        ret = methodInfo.Invoke( null, _parametersArray);
        #    }
        #    catch (Exception::CLRError)
        #    {
        #        //BP deviation documented
        #        e = CLRInterop::getLastException();
        #        throw error(e.ToString());
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #invokeStaticGenericType
        #/// <summary>
        #/// Вызов статической generic-функции класса. С одним типом generic.
        #/// </summary>
        #/// <param name="_classType">
        #/// Тип класса
        #/// </param>
        #/// <param name="_methodName">
        #/// Название функции
        #/// </param>
        #/// <param name="_methodType">
        #/// Тип generic
        #/// </param>
        #/// <param name="_parametersArray">
        #/// Массив параметров (можно сформировать с помощью функций getArray и getArrayFromContainer)
        #/// </param>
        #/// <param name="_overloaded">
        #/// Устанавливается в true для функций, имеющих несколько перегрузок
        #/// </param>
        #/// <returns>
        #/// Возвращаемый функцией результат
        #/// </returns>
        #/// <remarks>
        #///
        #/// </remarks>
        #static System.Object invokeStaticGenericType(
        #    System.Type        _classType
        #  , str                _methodName
        #  , System.Type        _methodType
        #  , System.Object[]    _parametersArray = null
        #  , boolean            _overloaded      = false
        #)
        #{
        #    return SysCLRReflection::invokeStaticGeneric(
        #        _classType
        #      , _methodName
        #      , SysCLRReflection::getTypeArray( _methodType)
        #      , _parametersArray
        #      , _overloaded
        #    );
        #}
      ENDSOURCE
      SOURCE #invokeStaticGenericType2
        #/// <summary>
        #/// Вызов статической generic-функции класса. С двумя типами generic.
        #/// </summary>
        #/// <param name="_classType">
        #/// Тип класса
        #/// </param>
        #/// <param name="_methodName">
        #/// Название функции
        #/// </param>
        #/// <param name="_methodType1">
        #/// Первый тип generic
        #/// </param>
        #/// <param name="_methodType2">
        #/// Второй тип generic
        #/// </param>
        #/// <param name="_parametersArray">
        #/// Массив параметров (можно сформировать с помощью функций getArray и getArrayFromContainer)
        #/// </param>
        #/// <param name="_overloaded">
        #/// Устанавливается в true для функций, имеющих несколько перегрузок
        #/// </param>
        #/// <returns>
        #/// Возвращаемый функцией результат
        #/// </returns>
        #/// <remarks>
        #///
        #/// </remarks>
        #static System.Object invokeStaticGenericType2(
        #    System.Type        _classType
        #  , str                _methodName
        #  , System.Type        _methodType1
        #  , System.Type        _methodType2
        #  , System.Object[]    _parametersArray = null
        #  , boolean            _overloaded      = false
        #)
        #{
        #    return SysCLRReflection::invokeStaticGeneric(
        #        _classType
        #      , _methodName
        #      , SysCLRReflection::getTypeArray( _methodType1, _methodType2)
        #      , _parametersArray
        #      , _overloaded
        #    );
        #}
      ENDSOURCE
      SOURCE #invokeStaticName
        #/// <summary>
        #/// Вызов статической функции класса. С указанием названия класса.
        #/// </summary>
        #/// <param name="_className">
        #/// Название класса
        #/// </param>
        #/// <param name="_methodName">
        #/// Название функции
        #/// </param>
        #/// <param name="_parametersArray">
        #/// Массив параметров (можно сформировать с помощью функций getArray и getArrayFromContainer)
        #/// </param>
        #/// <param name="_overloaded">
        #/// Устанавливается в true для функций, имеющих несколько перегрузок
        #/// </param>
        #/// <returns>
        #/// Возвращаемый функцией результат
        #/// </returns>
        #/// <remarks>
        #///
        #/// </remarks>
        #static System.Object invokeStaticName(
        #    str                 _className
        #  , str                 _methodName
        #  , System.Object[]     _parametersArray = null
        #  , boolean             _overloaded      = false
        #)
        #{
        #    return SysCLRReflection::invokeStaticGeneric(
        #        SysCLRType::newFromTypeName(_className).parmClrType()
        #      , _methodName
        #      , null
        #      , _parametersArray
        #      , _overloaded
        #    );
        #}
      ENDSOURCE
      SOURCE #invokeStaticNameGenericType
        #/// <summary>
        #/// Вызов статической generic-функции класса. С указанием названия класса. С указанием одного типа generic.
        #/// </summary>
        #/// <param name="_className">
        #/// Название класса
        #/// </param>
        #/// <param name="_methodName">
        #/// Название функции
        #/// </param>
        #/// <param name="_methodType">
        #/// Тип generic
        #/// </param>
        #/// <param name="_parametersArray">
        #/// Массив параметров (можно сформировать с помощью функций getArray и getArrayFromContainer)
        #/// </param>
        #/// <param name="_overloaded">
        #/// Устанавливается в true для функций, имеющих несколько перегрузок
        #/// </param>
        #/// <returns>
        #/// Возвращаемый функцией результат
        #/// </returns>
        #/// <remarks>
        #///
        #/// </remarks>
        #static System.Object invokeStaticNameGenericType(
        #    str                 _className
        #  , str                 _methodName
        #  , System.Type         _methodType
        #  , System.Object[]     _parametersArray = null
        #  , boolean             _overloaded      = false
        #)
        #{
        #    return SysCLRReflection::invokeStaticGeneric(
        #        SysCLRType::newFromTypeName(_className).parmClrType()
        #      , _methodName
        #      , SysCLRReflection::getTypeArray( _methodType)
        #      , _parametersArray
        #      , _overloaded
        #    );
        #}
      ENDSOURCE
      SOURCE #invokeStaticNameGenericType2
        #/// <summary>
        #/// Вызов статической generic-функции класса. С указанием названия класса. С указанием двух типов generic.
        #/// </summary>
        #/// <param name="_className">
        #/// Название класса
        #/// </param>
        #/// <param name="_methodName">
        #/// Название функции
        #/// </param>
        #/// <param name="_methodType1">
        #/// Первый тип generic
        #/// </param>
        #/// <param name="_methodType2">
        #/// Второй тип generic
        #/// </param>
        #/// <param name="_parametersArray">
        #/// Массив параметров (можно сформировать с помощью функций getArray и getArrayFromContainer)
        #/// </param>
        #/// <param name="_overloaded">
        #/// Устанавливается в true для функций, имеющих несколько перегрузок
        #/// </param>
        #/// <returns>
        #/// Возвращаемый функцией результат
        #/// </returns>
        #/// <remarks>
        #///
        #/// </remarks>
        #static System.Object invokeStaticNameGenericType2(
        #    str                 _className
        #  , str                 _methodName
        #  , System.Type         _methodType1
        #  , System.Type         _methodType2
        #  , System.Object[]     _parametersArray = null
        #  , boolean             _overloaded      = false
        #)
        #{
        #    return SysCLRReflection::invokeStaticGeneric(
        #        SysCLRType::newFromTypeName(_className).parmClrType()
        #      , _methodName
        #      , SysCLRReflection::getTypeArray( _methodType1, _methodType2)
        #      , _parametersArray
        #      , _overloaded
        #    );
        #}
      ENDSOURCE
      SOURCE #setPropertyValue
        #/// <summary>
        #/// Установка свойства CLR-объекта
        #/// </summary>
        #/// <param name="_class">
        #/// Объект
        #/// </param>
        #/// <param name="_propertyName">
        #/// Название свойства
        #/// </param>
        #/// <param name="_propertyValue">
        #/// Значение свойства
        #/// </param>
        #/// <remarks>
        #///
        #/// </remarks>
        #static void setPropertyValue(
        #    System.Object       _class
        #  , str                 _propertyName
        #  , System.Object       _propertyValue
        #)
        #{
        #;
        #    SysCLRReflection::setPropertyValuePrivate(
        #        _class
        #      , _propertyName
        #      , _propertyValue
        #    );
        #}
      ENDSOURCE
      SOURCE #setPropertyValueIndex
        #/// <summary>
        #/// Установка свойства CLR-объекта с одним индексом
        #/// </summary>
        #/// <param name="_class">
        #/// Объект
        #/// </param>
        #/// <param name="_propertyName">
        #/// Название свойства
        #/// </param>
        #/// <param name="_propertyValue">
        #/// Значение свойства
        #/// </param>
        #/// <param name="_index">
        #/// Индекс свойства
        #/// </param>
        #/// <remarks>
        #///
        #/// </remarks>
        #static void setPropertyValueIndex(
        #    System.Object       _class
        #  , str                 _propertyName
        #  , System.Object       _propertyValue
        #  , anytype             _index
        #)
        #{
        #;
        #    SysCLRReflection::setPropertyValuePrivate(
        #        _class
        #      , _propertyName
        #      , _propertyValue
        #      , SysCLRReflection::getArray( _index)
        #    );
        #}
      ENDSOURCE
      SOURCE #setPropertyValueIndex2
        #/// <summary>
        #/// Установка свойства CLR-объекта с двумя индексами
        #/// </summary>
        #/// <param name="_class">
        #/// Объект
        #/// </param>
        #/// <param name="_propertyName">
        #/// Название свойства
        #/// </param>
        #/// <param name="_propertyValue">
        #/// Значение свойства
        #/// </param>
        #/// <param name="_index1">
        #/// Первый индекс свойства
        #/// </param>
        #/// <param name="_index2">
        #/// Второй индекс свойства
        #/// </param>
        #/// <remarks>
        #///
        #/// </remarks>
        #static void setPropertyValueIndex2(
        #    System.Object       _class
        #  , str                 _propertyName
        #  , System.Object       _propertyValue
        #  , System.Object       _index1
        #  , System.Object       _index2
        #)
        #{
        #;
        #    SysCLRReflection::setPropertyValuePrivate(
        #        _class
        #      , _propertyName
        #      , _propertyValue
        #      , SysCLRReflection::getArray( _index1, _index2)
        #    );
        #}
      ENDSOURCE
      SOURCE #setPropertyValuePrivate
        #/// <summary>
        #/// Общая функция для установки свойства CLR-объекта
        #/// </summary>
        #/// <param name="_class">
        #/// Объект
        #/// </param>
        #/// <param name="_propertyName">
        #/// Название свойства
        #/// </param>
        #/// <param name="_propertyValue">
        #/// Значение свойства
        #/// </param>
        #/// <param name="_indexArray">
        #/// Массив индексов свойства
        #/// </param>
        #/// <remarks>
        #///
        #/// </remarks>
        #private static void setPropertyValuePrivate(
        #    System.Object       _class
        #  , str                 _propertyName
        #  , System.Object       _propertyValue
        #  , System.Object[]     _indexArray = null
        #)
        #{
        #    System.Type                         classType;
        #    System.Reflection.PropertyInfo      propertyInfo;
        #
        #    try
        #    {
        #        if ( !_indexArray
        #          || CLRInterop::isNull( _indexArray) )
        #        {
        #            _indexArray    = new System.Object[0]();
        #        }
        #
        #        classType       = _class.GetType();
        #
        #        propertyInfo    = classType.GetProperty(_propertyName);
        #        if ( !CLRInterop::isNull(propertyInfo))
        #        {
        #            propertyInfo.SetValue( _class, _propertyValue, _indexArray);
        #        }
        #        else
        #            throw Error( strfmt("Свойство %1 в классе %2 не найдено!", _propertyName, CLRInterop::getAnyTypeForObject(classType.ToString())));
        #    }
        #    catch (Exception::CLRError)
        #    {
        #        throw error(AifUtil::getClrErrorMessage());
        #    }
        #}
      ENDSOURCE
      SOURCE #typeArray2Str
        #/// <summary>
        #/// Преобразование массива типов System.Type[] в строку, где типы перечислены через запятую
        #/// </summary>
        #/// <param name="typeArray">
        #/// Массив типов System.Type[]
        #/// </param>
        #/// <returns>
        #///
        #/// </returns>
        #/// <remarks>
        #///
        #/// </remarks>
        #private static str typeArray2Str(
        #    System.Type[]   typeArray
        #)
        #{
        #    str         ret;
        #    int         i;
        #    System.Type type;
        #;
        #    for (i=0; i< CLRInterop::getAnyTypeForObject(typeArray.get_Length()); i++)
        #    {
        #        type    = typeArray.GetValue(i);
        #        ret += (ret?",":"") + CLRInterop::getAnyTypeForObject(type.ToString());
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: CLS

; Microsoft Dynamics AX Class: SysCLRReflectionTest выгружен
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #SysCLRReflectionTest
    PROPERTIES
      Name                #SysCLRReflectionTest
      Extends             #SysTestCase
      RunOn               #Server
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #classDeclaration
        #class SysCLRReflectionTest extends SysTestCase
        #{
        #}
      ENDSOURCE
      SOURCE #testGetArray
        #void testGetArray()
        #{
        #    System.Object[] array;
        #;
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    array   = SysCLRReflection::getArray();
        #    this.assertNotNull( array);
        #
        #    array   = SysCLRReflection::getArray( "test1");
        #    this.assertNotNull( array);
        #
        #    array   = SysCLRReflection::getArray( "test1", "test2");
        #    this.assertNotNull( array);
        #
        #    array   = SysCLRReflection::getArray( 100);
        #    this.assertNotNull( array);
        #
        #    array   = SysCLRReflection::getArray( 100, 200);
        #    this.assertNotNull( array);
        #}
      ENDSOURCE
      SOURCE #testGetArrayCLR
        #void testGetArrayCLR()
        #{
        #    System.Object[] array;
        #    System.Type     type1;
        #    System.Type     type2;
        #;
        #    new InteropPermission(InteropKind::ClrInterop).assert();
        #
        #    array   = SysCLRReflection::getArray();
        #    this.assertNotNull( array);
        #
        #    type1   = System.Type::GetType("System.String");
        #    array   = SysCLRReflection::getArray( type1);
        #    this.assertNotNull( array);
        #
        #    type2   = System.Type::GetType("System.Int32");
        #    array   = SysCLRReflection::getArray( type1, type2);
        #    this.assertNotNull( array);
        #}
      ENDSOURCE
      SOURCE #testGetNotexistPropertyValue
        #void testGetNotexistPropertyValue()
        #{
        #    System.String   s;
        #    int             result;
        #;
        #    new InteropPermission( InteropKind::ClrInterop).assert();
        #
        #    s = "test";
        #
        #    this.parmExceptionExpected( true, "Свойство NotexistProperty в классе System.String не найдено!");
        #
        #    result  = SysCLRReflection::getPropertyValue(
        #        s
        #      , "NotexistProperty"
        #    );
        #}
      ENDSOURCE
      SOURCE #testGetPropertyValue
        #void testGetPropertyValue()
        #{
        #    System.String   s;
        #    int             result;
        #;
        #    new InteropPermission( InteropKind::ClrInterop).assert();
        #
        #    s = "test";
        #
        #    result  = SysCLRReflection::getPropertyValue(
        #        s
        #      , "Length"
        #    );
        #    this.assertEquals( 4, result);
        #}
      ENDSOURCE
      SOURCE #testInvokeNotexistMethod
        #void testInvokeNotexistMethod()
        #{
        #    System.String   s;
        #    str             result;
        #;
        #    new InteropPermission( InteropKind::ClrInterop).assert();
        #
        #    s = "test";
        #
        #    this.parmExceptionExpected( true, "Метод NotexistMethod в классе System.String не найден!");
        #    result  = SysCLRReflection::invokeMethod( s, "NotexistMethod");
        #}
      ENDSOURCE
      SOURCE #testInvokeNotexistMethodGenericType
        #void testInvokeNotexistMethodGenericType()
        #{
        #    System.String   s;
        #    str             result;
        #;
        #    new InteropPermission( InteropKind::ClrInterop).assert();
        #
        #    s = "test";
        #
        #    this.parmExceptionExpected( true, "Метод NotexistMethod в классе System.String не найден!");
        #
        #    result  = SysCLRReflection::invokeMethodGenericType(
        #        s
        #      , "NotexistMethod"
        #      , SysCLRType::newFromTypeName("System.Int32").parmClrType()
        #    );
        #}
      ENDSOURCE
      SOURCE #testInvokeNotexistMethodGenericType2
        #void testInvokeNotexistMethodGenericType2()
        #{
        #    System.String   s;
        #    str             result;
        #;
        #    new InteropPermission( InteropKind::ClrInterop).assert();
        #
        #    s = "test";
        #
        #    this.parmExceptionExpected( true, "Метод NotexistMethod в классе System.String не найден!");
        #
        #    result  = SysCLRReflection::invokeMethodGenericType2(
        #        s
        #      , "NotexistMethod"
        #      , SysCLRType::newFromTypeName("System.Int32").parmClrType()
        #      , SysCLRType::newFromTypeName("System.String").parmClrType()
        #    );
        #}
      ENDSOURCE
      SOURCE #testInvokeNotexistMethodGenericTypeName
        #void testInvokeNotexistMethodGenericTypeName()
        #{
        #    System.String   s;
        #    str             result;
        #;
        #    new InteropPermission( InteropKind::ClrInterop).assert();
        #
        #    s = "test";
        #
        #    this.parmExceptionExpected( true, "Метод NotexistMethod в классе System.String не найден!");
        #
        #    result  = SysCLRReflection::invokeMethodGenericTypeName(
        #        s
        #      , "NotexistMethod"
        #      , "System.Int32"
        #    );
        #}
      ENDSOURCE
      SOURCE #testInvokeNotexistMethodGenericTypeName2
        #void testInvokeNotexistMethodGenericTypeName2()
        #{
        #    System.String   s;
        #    str             result;
        #;
        #    new InteropPermission( InteropKind::ClrInterop).assert();
        #
        #    s = "test";
        #
        #    this.parmExceptionExpected( true, "Метод NotexistMethod в классе System.String не найден!");
        #
        #    result  = SysCLRReflection::invokeMethodGenericTypeName2(
        #        s
        #      , "NotexistMethod"
        #      , "System.Int32"
        #      , "System.String"
        #    );
        #}
      ENDSOURCE
      SOURCE #testInvokeParameterOne
        #void testInvokeParameterOne()
        #{
        #    System.String   s;
        #    boolean         result;
        #;
        #    new InteropPermission( InteropKind::ClrInterop).assert();
        #
        #    s = "test";
        #
        #    result  = SysCLRReflection::invokeMethod(
        #        s
        #      , "Contains"
        #      , SysCLRReflection::getArray("s")
        #    );
        #
        #    this.assertTrue( result);
        #
        #    result  = SysCLRReflection::invokeMethod(
        #        s
        #      , "Contains"
        #      , SysCLRReflection::getArray("i")
        #    );
        #
        #    this.assertFalse( result);
        #}
      ENDSOURCE
      SOURCE #testInvokeParameterTwo
        #void testInvokeParameterTwo()
        #{
        #    System.String   s;
        #    str             result;
        #;
        #    new InteropPermission( InteropKind::ClrInterop).assert();
        #
        #    s = "test";
        #
        #    result  = SysCLRReflection::invokeMethod(
        #        s
        #      , "Replace"
        #      , SysCLRReflection::getArray( "s", "v")
        #      , true
        #    );
        #
        #    this.assertEquals( "tevt", result);
        #}
      ENDSOURCE
      SOURCE #testInvokeSimple
        #void testInvokeSimple()
        #{
        #    System.String   s;
        #    str             result;
        #;
        #    new InteropPermission( InteropKind::ClrInterop).assert();
        #
        #    s = "test";
        #
        #    result  = SysCLRReflection::invokeMethod( s, "Clone");
        #
        #    this.assertEquals( "test", result);
        #}
      ENDSOURCE
      SOURCE #testSetNotexistPropertyValue
        #void testSetNotexistPropertyValue()
        #{
        #    System.Collections.ArrayList   s;
        #;
        #    new InteropPermission( InteropKind::ClrInterop).assert();
        #
        #    s   = new System.Collections.ArrayList();
        #
        #    this.parmExceptionExpected( true, "Свойство NotexistProperty в классе System.Collections.ArrayList не найдено!");
        #    SysCLRReflection::setPropertyValue(
        #        s
        #      , "NotexistProperty"
        #      , 10
        #    );
        #}
      ENDSOURCE
      SOURCE #testSetPropertyValue
        #void testSetPropertyValue()
        #{
        #    System.Collections.ArrayList   s;
        #;
        #    new InteropPermission( InteropKind::ClrInterop).assert();
        #
        #    s   = new System.Collections.ArrayList();
        #
        #    SysCLRReflection::setPropertyValue(
        #        s
        #      , "Capacity"
        #      , 10
        #    );
        #    this.assertEquals( 10, CLRInterop::getAnyTypeForObject(s.get_Capacity()));
        #}
      ENDSOURCE
      SOURCE #testSetPropertyValueIndex
        #void testSetPropertyValueIndex()
        #{
        #    System.Collections.ArrayList   s;
        #;
        #    new InteropPermission( InteropKind::ClrInterop).assert();
        #
        #    s   = new System.Collections.ArrayList(3);
        #    this.assertEquals( 3, CLRInterop::getAnyTypeForObject(s.get_Capacity()));
        #    s.Add( "01");
        #    s.Add( "02");
        #    s.Add( "03");
        #
        #    SysCLRReflection::setPropertyValueIndex(
        #        s
        #      , "Item"
        #      , 10
        #      , 1
        #    );
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: PRN

; Microsoft Dynamics AX Project : SysCLRReflection unloaded
; --------------------------------------------------------------------------------
  PROJECTVERSION 2
  
  PROJECT #SysCLRReflection
   SHARED
  PROPERTIES
    Name                #SysCLRReflection
  ENDPROPERTIES
  
    PROJECTCLASS ProjectNode
    BEGINNODE
      FILETYPE 0
      UTILTYPE 45
      UTILOBJECTID 41901
      NODETYPE 329
      NAME #SysCLRReflection
    ENDNODE
    BEGINNODE
      FILETYPE 0
      UTILTYPE 45
      UTILOBJECTID 41902
      NODETYPE 329
      NAME #SysCLRReflectionTest
    ENDNODE
  ENDPROJECT
  

***Element: END
